<?xml version="1.0" encoding="UTF-8"?>
<scave:Analysis xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:scave="http://www.omnetpp.org/omnetpp/scave">
  <inputs>
    <inputs name="results/G-bitrate*.sca"/>
    <inputs name="results/nBestAMSDUSize-msduSize=100000,bitrate=*,packetLength=*-#0.sca"/>
  </inputs>
  <charts>
    <items xsi:type="scave:MatplotlibChart" name="Throughput - 802.11g" input="import math&#xA;&#xA;def computeThroughput(payloadLength, dataBitrate) :&#xA;    DIFS = 28&#xA;    SIFS = 10&#xA;    slotTime = 9&#xA;    minContentionWindow = 15&#xA;    plcpPreambleDuration = 16&#xA;    plcpHeaderDuration = 4&#xA;    macHeaderLength = 16 + 28 * 8 + 6&#xA;    udpHeaderLength = 8 * 8&#xA;    ipHeaderLength = 20 * 8&#xA;    llcHeaderLength = 8 * 8&#xA;    frameLength = udpHeaderLength + ipHeaderLength + llcHeaderLength + macHeaderLength + payloadLength&#xA;    signalExtensionDuration = 6&#xA;    dataDuration = math.ceil(frameLength / dataBitrate / 4) * 4&#xA;    dataFrameDuration = plcpPreambleDuration + plcpHeaderDuration + dataDuration + signalExtensionDuration&#xA;    ackBitrate = 24 if dataBitrate >= 24 else 12 if dataBitrate >= 12 else 6&#xA;    ackLength = 16 + 112 + 6&#xA;    ackDuration = math.ceil(ackLength / ackBitrate / 4) * 4&#xA;    ackFrameDuration = plcpPreambleDuration + plcpHeaderDuration + ackDuration + signalExtensionDuration&#xA;    backoffDuration = minContentionWindow / 2 * slotTime&#xA;    frameExchangeDuration = DIFS + backoffDuration + dataFrameDuration + SIFS + ackFrameDuration&#xA;    throughput = 1 / frameExchangeDuration * payloadLength&#xA;    return throughput&#xA;&#xA;df = results.getScalars(&quot;ADD scalars WHERE run(G*) AND module(Throughput.destinationHost.app[0]) AND name(throughput:mean)&quot;)&#xA;df = results.pivotScalars(df, [&quot;packetLength&quot;], [&quot;bitrate&quot;])&#xA;df /= 1e+6&#xA;df.index = df.index.astype(int)&#xA;&#xA;for c in df.columns :&#xA;    df[&quot;Analytical &quot; + str(c) + &quot; B&quot;] = list(map(lambda bitrate : computeThroughput(int(c) * 8, bitrate), df.index))&#xA;    df.rename(columns = {c : &quot;Simulated &quot; + c + &quot; B&quot;}, inplace = True)&#xA;&#xA;df.sort_index(inplace = True)&#xA;df.plot.line()"/>
    <items xsi:type="scave:MatplotlibChart" name="Throughput - 802.11n" input="import math&#xA;&#xA;# Units are b, Mbps, us&#xA;def computeThroughput(payloadLength, dataBitrate, aggregationCount) :&#xA;    DIFS = 28&#xA;    SIFS = 10&#xA;    slotTime = 9&#xA;    minContentionWindow = 15&#xA;    plcpPreambleDuration = 16&#xA;    plcpHeaderDuration = 4&#xA;    macHeaderLength = 16 + 28 * 8 + 6&#xA;    msduSubframeHeaderLength = 14 * 8&#xA;    udpHeaderLength = 8 * 8&#xA;    ipHeaderLength = 20 * 8&#xA;    llcHeaderLength = 8 * 8&#xA;    paddingLength = 2 * 8 # TODO&#xA;    frameLength = macHeaderLength + (msduSubframeHeaderLength + llcHeaderLength + ipHeaderLength + udpHeaderLength + payloadLength + paddingLength) * aggregationCount&#xA;# if there is no aggregation, then msduSubframeHeaderLength and padding is not needed ?&#xA;    print(&quot;frameLength:&quot;)&#xA;    print(frameLength / 8)&#xA;    signalExtensionDuration = 6&#xA;    dataDuration = math.ceil(frameLength / dataBitrate / 4) * 4&#xA;    dataFrameDuration = plcpPreambleDuration + plcpHeaderDuration + dataDuration + signalExtensionDuration&#xA;    print(&quot;dataDuration:&quot;)&#xA;    print(dataDuration)&#xA;    ackBitrate = 24 if dataBitrate >= 24 else 12 if dataBitrate >= 12 else 6&#xA;    ackLength = 16 + 112 + 6&#xA;    ackDuration = math.ceil(ackLength / ackBitrate / 4) * 4&#xA;    ackFrameDuration = plcpPreambleDuration + plcpHeaderDuration + ackDuration + signalExtensionDuration&#xA;    backoffDuration = minContentionWindow / 2 * slotTime&#xA;    frameExchangeDuration = DIFS + backoffDuration + dataFrameDuration + SIFS + ackFrameDuration&#xA;    print(&quot;frame exchange duration without b.o.:&quot;)&#xA;    print(frameExchangeDuration - backoffDuration)&#xA;    print(&quot;&quot;)&#xA;    throughput = 1 / frameExchangeDuration * payloadLength * aggregationCount&#xA;    return throughput&#xA;&#xA;df = results.getScalars(&quot;ADD scalars WHERE run(n*) AND module(Throughput.destinationHost.app[0]) AND name(throughput:mean)&quot;)&#xA;df = results.pivotScalars(df, [&quot;packetLength&quot;], [&quot;bitrate&quot;])&#xA;df /= 1e+6&#xA;df.index = df.index.astype(int)&#xA;&#xA;for c in df.columns :&#xA;    df[&quot;Analytical &quot; + str(c) + &quot; B&quot;] = list(map(lambda bitrate : computeThroughput(int(c) * 8, bitrate, 9), df.index))&#xA;    df.rename(columns = {c : &quot;Simulated &quot; + c + &quot; B&quot;}, inplace = True)&#xA;&#xA;df.sort_index(inplace = True)&#xA;df.plot.line()"/>
    <items xsi:type="scave:ScatterChart" name="Throughput - 802.11g scatterchart" input="import math&#xA;&#xA;def computeThroughput(payloadLength, dataBitrate) :&#xA;    DIFS = 28&#xA;    SIFS = 10&#xA;    slotTime = 9&#xA;    minContentionWindow = 15&#xA;    plcpPreambleDuration = 16&#xA;    plcpHeaderDuration = 4&#xA;    macHeaderLength = 16 + 28 * 8 + 6&#xA;    udpHeaderLength = 8 * 8&#xA;    ipHeaderLength = 20 * 8&#xA;    llcHeaderLength = 8 * 8&#xA;    frameLength = udpHeaderLength + ipHeaderLength + llcHeaderLength + macHeaderLength + payloadLength&#xA;    signalExtensionDuration = 6&#xA;    dataDuration = math.ceil(frameLength / dataBitrate / 4) * 4&#xA;    dataFrameDuration = plcpPreambleDuration + plcpHeaderDuration + dataDuration + signalExtensionDuration&#xA;    ackBitrate = 24 if dataBitrate >= 24 else 12 if dataBitrate >= 12 else 6&#xA;    ackLength = 16 + 112 + 6&#xA;    ackDuration = math.ceil(ackLength / ackBitrate / 4) * 4&#xA;    ackFrameDuration = plcpPreambleDuration + plcpHeaderDuration + ackDuration + signalExtensionDuration&#xA;    backoffDuration = minContentionWindow / 2 * slotTime&#xA;    frameExchangeDuration = DIFS + backoffDuration + dataFrameDuration + SIFS + ackFrameDuration&#xA;    throughput = 1 / frameExchangeDuration * payloadLength&#xA;    return throughput&#xA;&#xA;df = results.getScalars(&quot;ADD scalars WHERE module(Throughput.destinationHost.app[0]) AND name(throughput:mean)&quot;)&#xA;df = results.pivotScalars(df, [&quot;packetLength&quot;], [&quot;bitrate&quot;])&#xA;df /= 1e+6&#xA;df.index = df.index.astype(int)&#xA;&#xA;for c in df.columns :&#xA;    df[&quot;Analytical &quot; + str(c) + &quot; B&quot;] = list(map(lambda bitrate : computeThroughput(int(c) * 8, bitrate), df.index))&#xA;    df.rename(columns = {c : &quot;Simulated &quot; + c + &quot; B&quot;}, inplace = True)&#xA;&#xA;df.sort_index(inplace = True)&#xA;# df.plot.line()&#xA;&#xA;chart.plotVectors(df)"/>
    <items xsi:type="scave:ScatterChart" name="" input="import math&#xA;&#xA;def computeThroughput(payloadLength, dataBitrate) :&#xA;    DIFS = 28&#xA;    SIFS = 10&#xA;    slotTime = 9&#xA;    minContentionWindow = 15&#xA;    plcpPreambleDuration = 16&#xA;    plcpHeaderDuration = 4&#xA;    macHeaderLength = 16 + 28 * 8 + 6&#xA;    udpHeaderLength = 8 * 8&#xA;    ipHeaderLength = 20 * 8&#xA;    llcHeaderLength = 8 * 8&#xA;    frameLength = udpHeaderLength + ipHeaderLength + llcHeaderLength + macHeaderLength + payloadLength&#xA;    signalExtensionDuration = 6&#xA;    dataDuration = math.ceil(frameLength / dataBitrate / 4) * 4&#xA;    dataFrameDuration = plcpPreambleDuration + plcpHeaderDuration + dataDuration + signalExtensionDuration&#xA;    ackBitrate = 24 if dataBitrate >= 24 else 12 if dataBitrate >= 12 else 6&#xA;    ackLength = 16 + 112 + 6&#xA;    ackDuration = math.ceil(ackLength / ackBitrate / 4) * 4&#xA;    ackFrameDuration = plcpPreambleDuration + plcpHeaderDuration + ackDuration + signalExtensionDuration&#xA;    backoffDuration = minContentionWindow / 2 * slotTime&#xA;    frameExchangeDuration = DIFS + backoffDuration + dataFrameDuration + SIFS + ackFrameDuration&#xA;    throughput = 1 / frameExchangeDuration * payloadLength&#xA;    return throughput&#xA;&#xA;df = results.getScalars(&quot;ADD scalars WHERE module(Throughput.destinationHost.app[0]) AND name(throughput:mean)&quot;)&#xA;df = results.pivotScalars(df, [&quot;packetLength&quot;], [&quot;bitrate&quot;])&#xA;df /= 1e+6&#xA;df.index = df.index.astype(int)&#xA;&#xA;for c in df.columns :&#xA;    df[&quot;Analytical &quot; + str(c) + &quot; B&quot;] = list(map(lambda bitrate : computeThroughput(int(c) * 8, bitrate), df.index))&#xA;    df.rename(columns = {c : &quot;Simulated &quot; + c + &quot; B&quot;}, inplace = True)&#xA;&#xA;df.sort_index(inplace = True)&#xA;df.plot.line()&#xA;&#xA;print(df)&#xA;&#xA;#chart.plotVectors(df[&quot;bitrate&quot;],df[&quot;packetLength&quot;])"/>
    <items xsi:type="scave:MatplotlibChart" name="Top-of-MAC Throughput 80211n" input="import math&#xA;&#xA;# Units are b, Mbps, us&#xA;def computeThroughput(payloadLength, dataBitrate, aggregationCount) :&#xA;    DIFS = 28&#xA;    SIFS = 10&#xA;    slotTime = 9&#xA;    minContentionWindow = 15&#xA;    plcpPreambleDuration = 16&#xA;    plcpHeaderDuration = 4&#xA;    macHeaderLength = 16 + 28 * 8 + 6&#xA;    msduSubframeHeaderLength = 14 * 8&#xA;    udpHeaderLength = 8 * 8&#xA;    ipHeaderLength = 20 * 8&#xA;    llcHeaderLength = 8 * 8&#xA;    paddingLength = 2 * 8 # TODO&#xA;    frameLength = macHeaderLength + (msduSubframeHeaderLength + llcHeaderLength + ipHeaderLength + udpHeaderLength + payloadLength + paddingLength) * aggregationCount&#xA;# if there is no aggregation, then msduSubframeHeaderLength and padding is not needed ?&#xA;    print(&quot;frameLength:&quot;)&#xA;    print(frameLength / 8)&#xA;    signalExtensionDuration = 6&#xA;    dataDuration = math.ceil(frameLength / dataBitrate / 4) * 4&#xA;    dataFrameDuration = plcpPreambleDuration + plcpHeaderDuration + dataDuration + signalExtensionDuration&#xA;    print(&quot;dataDuration:&quot;)&#xA;    print(dataDuration)&#xA;    ackBitrate = 24 if dataBitrate >= 24 else 12 if dataBitrate >= 12 else 6&#xA;    ackLength = 16 + 112 + 6&#xA;    ackDuration = math.ceil(ackLength / ackBitrate / 4) * 4&#xA;    ackFrameDuration = plcpPreambleDuration + plcpHeaderDuration + ackDuration + signalExtensionDuration&#xA;    backoffDuration = minContentionWindow / 2 * slotTime&#xA;    frameExchangeDuration = DIFS + backoffDuration + dataFrameDuration + SIFS + ackFrameDuration&#xA;    print(&quot;frame exchange duration without b.o.:&quot;)&#xA;    print(frameExchangeDuration - backoffDuration)&#xA;    print(&quot;&quot;)&#xA;    throughput = 1 / frameExchangeDuration * (payloadLength + llcHeaderLength + ipHeaderLength + udpHeaderLength) * aggregationCount&#xA;    return throughput&#xA;&#xA;df = results.getScalars(&quot;ADD scalars WHERE run(n*) AND module(Throughput.destinationHost.app[0]) AND name(throughput:mean)&quot;)&#xA;df = results.pivotScalars(df, [&quot;packetLength&quot;], [&quot;bitrate&quot;])&#xA;df /= 1e+6&#xA;df.index = df.index.astype(int)&#xA;&#xA;for c in df.columns :&#xA;    df[&quot;Analytical &quot; + str(c) + &quot; B&quot;] = list(map(lambda bitrate : computeThroughput(int(c) * 8, bitrate, 9), df.index))&#xA;    df.rename(columns = {c : &quot;Simulated &quot; + c + &quot; B&quot;}, inplace = True)&#xA;&#xA;df.sort_index(inplace = True)&#xA;df.plot.line()"/>
  </charts>
</scave:Analysis>
